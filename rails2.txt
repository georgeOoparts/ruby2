新しいプロジェクト（tweet_app）を作る　必要なファイルができる
rails new tweet_app

------------------------
サーバを立ち上げる（localhost:3000）
rails server

------------------------
ホームフォルダにtop.html.erbを作る
その他、必要ファイルも作る（2度と同じコントローラ名は使えない）
コントローラを作る
初めコントローラ

rails generate controller home（コンロローラ） top（アクション）
---------
erb
アプリ名＞app＞views>home＞top.html.erb

controller.rb
アプリ名＞app＞controller>home_controller.rb

routes.rb
app>config>routes.rb
------------------------
app>config>routes.rbの構成

get "URL" => "フォルダ構成"
get "home/top" => "home#top"
----------
呼び出されるページのURL変更
get "URL変更" => "home#top"
------------------------
CSSファイルは「app/assets/stylesheets」フォルダに入っています。
今回の場合rails generate controller home top コマンド絵
home.scssができている

------------------------
画像
app>public 配下に画像ファイルと入れる　例　ファイル名.png
<img src="/ファイル名.png">で表示
------------------------
リンクの作りから

html　
<a href="/"></a>    
>>>
ルーター
get"/"=>"home#top"
------------------------
htmlにルビーのコードを埋め込む
<%post="ルビーのスクリプト"%>

変数の値を表示
<%=post%>
------------------------
railsではコントローラに@変数名で変数を定義し、erbファイルで使いまわす

class PostsController < ApplicationController
  def index
    # viewで定義していた配列postsを@postsという変数名で定義してください
    @posts=
    [
      "今日からProgateでRailsの勉強するよー！",
      "投稿一覧ページ作成中！"
    ]
  end
end
-------------
この場合index.erbファイルで
<%=@posts%>で使いまわす
------------------------
データベース最初
マイグレーションファイルと呼ばれる、データベースに変更を指示するためのファイルを作成しましょう。
データベースcontentという行（カラム）にtextという文字列を入れる型で作ると
rails g model Post content:text

rails g model Post カラム名:データの型

db/migrateフォルダの下にマイグレーションファイルが作成されます。
---------
マイグレーションファイルに書いてる通りデータベースを変更する
rails db:migrate

---------
rails g model Post content:text

rails g model モデル名 カラム名:データの型
ここで改めて「rails g model」コマンドについて見てみましょう。
「rails g model Post ...」の「Post」の部分には、実はモデル名を指定します。
そして、このコマンドによって、以下の2つのファイルが作成されます。
・app/modelsフォルダにモデルが定義されたpost.rbができる
・db/migrateフォルダにマイグレーションファイル
------------------------
ターミナル上で「rails console」と入力し実行（Enter）することで、
コンソールを起動することができます。コンソールを起動した状態で、
「1+1」を実行すると、その実行結果が表示されます。
また、「quit」を実行すると、コンソールを終了することができます。
--------
データの作成
 
モデル名Postのapp/modelsフォルダにモデルが定義されたpost.rbのインスタンスを作る
post1 = Post.new(content: "今日からProgateでRailsの勉強するよー！")

作られたインスタンスをデータベースにセーブ。
post1.save
------------
データベースの最初の値を取り出す。コンソール

「Post.first」 posts テーブルにある最初のデータを取得することができるぞ。

変数にデータベースから取得したものを代入
post=Post.first
-------
コンソール　取得したデータベースの行のカラムを取得
post.content
-------
データベースのすべての要素を取得
「Post.all」 
------------------------
「Post.all[0]」=「Post.first」
------------------------
コントローラで@posts=Post.allにして

erbファイルでよく使うパターン
<% @posts.each do |post| %>
      <div class="posts-index-item">
        <!-- post.contentを使って書き換えてください -->
        <%= post.content %>
      </div>
<% end %>

------------------------
Railsでは、「views/layouts/application.html.erb」
に共通のHTMLを書いておくことができます。

「views/layouts/application.html.erb」には<%= yield %>というコードがあります。
top.html.erbなどの各ビューファイルは、この<%= yield %>の部分に代入され、
application.html.erbの一部としてブラウザに表示されていました。
この仕組みによって、ヘッダーなどの共通のレイアウトを1つにまとめることができます。
------------------------
erbファイルでリンク　/が入る注意　
<%= link_to("表示する文字列", "/アドレス") %>
------------------------
「モデル名.find_by(カラム名: 値)」とすることで、
その値を持ったデータをデータベースから取得することができます。
Post.find_by(id: 2)など
------------------------
・ .content（カラム名）を実行、投稿内容を取得してください。
・ .created_at（デフォルトであるカラム）を実行、投稿時刻を取得してください。
------------------------
urlが「/posts/1」「/posts/2」のようなページを作る
＞コントローラのアクションで同じ変数を使いまわす

ルーティングのURL部分に「:」を用いて「posts/:id」と指定することで、
「/posts/1」でも「/posts/2」でもshowアクションにいくようにすることができます。
「posts/:id」と書くと「/posts/◯◯」のような全てのURLが該当します。

注意＊＊＊＊＊これだめ
get"posts/:id"=>"posts#show"
get"posts/index"=>"posts#index"

上からよみこまれるため、posts/indexのアクションを取得できない
get"posts/index"=>"posts#index"
 get"posts/:id"=>"posts#show"
のように順番を変える
--------
ルータの:idをコントローラで整数として取得
def show
	@id=params[:id]
end

コントローラのアクション内では、
ルーティングで設定したURLの「:id」の値を取得することができます。
その値はparamsという変数にハッシュとして入っています。
params[:id]とすることで、その値を取得することができます。

posts/１やposts/2にたいして{id:1}、{id:2}がハッシュとして取得できる
----------
erbファイルの変数の表示のしかた
<%="idが「#{@id}」の投稿詳細画面です"%>
------------------------
データベースのidを得る
.id
------------------------
よく使うあw世話座
データベースの内容表示と　詳細ページへのリンク
erbファイル
<% @posts.each do |post| %>
      <div class="posts-index-item">
        <!-- 以下をlink_toメソッドを用いて書き換えてください -->
        <%= link_to(post.content, "/posts/#{post.id}") %>
      </div>
<% end %>
------------------------
データベースの情報をhtmlのformから受け取る
ルータ
post "posts/create"=>"posts#create"
コントローラ　アクション追加
def create
	//:contentでformから送られてきた情報を得る
	@post=Post.new(content:params[:content])
	@post.save

end


erbファイル
<%=form_tag(送信先のURL) do%>

<%=form_tag("/posts/create") do%>
	<textarea　name="content"></textarea>
	<input type="submit"value="投稿">
<%end%>






reateアクションのルーティングを設定しましょう。
今までルーティングを書く際に「get」と書いてきましたが、
フォームの値を受け取る場合は「post」とする必要があります。
（この「post」はPostモデルの「Post」とは関係ありません。）
通常は「get」、フォームの値を受け取るときは「post」というように覚えておきましょう。


form_tagメソッドを用いると、フォームに入力されたデータを送信することができます。
form_tagは、「form_tag(送信先のURL) do」のように送信先のURLを指定します。
これによって、<input type="submit" ...>のボタンを押した時に、
指定されたURLにデータが送信されます。

<textarea>タグにname属性を指定すると、入力データを送信することができるようになり、
name属性の値をキーとしたハッシュがRails側に送られます。

name属性を指定したフォームに入力されたデータは、
コントローラのアクション内で受け取ることが可能になります。
フォームのデータは、変数paramsで受け取ります。
paramsはname属性に設定した文字列をキーとしたハッシュになっています。
------------------------
他のURLに転送（リダイレクト）するには、redirect_toメソッドを用います。
redirect_toは「redirect_to(URL)」とすることで、そのページに転送することができます。



------------------------
入力データを受け取るためのparamsはURLからidの値を取得するときにも使いました。
paramsは以下の2通りの使い方があるので、整理して覚えておきましょう。
コントローラで使う
①「:○○」を使ったルーティングのURLから値を取得する
②「name="○○"」が付いたフォームの入力内容を受け取る

------------------------
データベースから変数に代入するデータの並び順を
降順にする　並び順
.order(created_at: :desc)
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------
------------------------




















